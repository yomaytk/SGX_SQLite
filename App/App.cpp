#include <stdio.h>
#include <iostream>
#include <string>
#include <assert.h>
#include <fstream>
#include <thread>
#include "sgx_urts.h"
#include "Enclave_u.h" // Headers for untrusted part (autogenerated by edger8r)

using namespace std;

# define MAX_PATH FILENAME_MAX
# define ENCLAVE_FILENAME "enclave.signed.so"

// ocalls for printing string (C++ ocalls)
void ocall_print_error(const char *str){
    cerr << str << endl;
}

void ocall_print_string(const char *str){
    cout << str;
}

void ocall_println_string(const char *str){
    cout << str << endl;
}

void ocall_text_print(uint8_t *data, uint32_t data_size) {
    for(int i = 0;i < data_size;i++) {
        std::cout << data[i];
    }
    return;
}

static size_t get_file_size(const char *filename)
{
    std::ifstream ifs(filename, std::ios::in | std::ios::binary);
    if (!ifs.good())
    {
        std::cout << "Failed to open the file \"" << filename << "\"" << std::endl;
        return -1;
    }
    ifs.seekg(0, std::ios::end);
    size_t size = (size_t)ifs.tellg();
    return size;
}

static bool read_file_to_buf(const char *filename, uint8_t *buf, size_t bsize)
{
    if (filename == NULL || buf == NULL || bsize == 0)
        return false;
    std::ifstream ifs(filename, std::ios::binary | std::ios::in);
    if (!ifs.good())
    {
        std::cout << "Failed to open the file \"" << filename << "\"" << std::endl;
        return false;
    }
    ifs.read(reinterpret_cast<char *> (buf), bsize);
    if (ifs.fail())
    {
        std::cout << "Failed to read the file \"" << filename << "\"" << std::endl;
        return false;
    }
    return true;
}

static bool write_buf_to_file(const char *filename, const uint8_t *buf, size_t bsize, long offset)
{
    if (filename == NULL || buf == NULL || bsize == 0)
        return false;
    std::ofstream ofs(filename, std::ios::binary | std::ios::out);
    if (!ofs.good())
    {
        std::cout << "Failed to open the file \"" << filename << "\"" << std::endl;
        return false;
    }
    ofs.seekp(offset, std::ios::beg);
    ofs.write(reinterpret_cast<const char*>(buf), bsize);
    if (ofs.fail())
    {
        std::cout << "Failed to write the file \"" << filename << "\"" << std::endl;
        return false;
    }

    return true;
}

// initialize enclave
static sgx_status_t initialize_enclave(sgx_enclave_id_t *eid, sgx_launch_token_t *token, int *updated) {
    sgx_status_t ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, token, updated, eid, NULL);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return SGX_ERROR_UNEXPECTED;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;
    return SGX_SUCCESS;
}

// Application entry
int main(int argc, char *argv[]){

    if ( argc != 2 ){
        cout << "Usage: " << argv[0] << " <database>" << endl;
        return -1;
    }
    const char* dbname = argv[1];
    size_t len = 0;

    for (int i = 0;dbname[i] != '\0';i++)
        len++;

    char *sealed_db_file = (char *)malloc(len+strlen(".signed"));
    strcpy(sealed_db_file, dbname);
    strcpy(sealed_db_file+len, ".signed");
    // std::cout << sealed_db_file << endl;

    sgx_enclave_id_t eid = 0;
    char token_path[MAX_PATH] = {'\0'};
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    initialize_enclave(&eid, &token, &updated);

    // Sealing
    uint32_t sealed_data_size = 0;
    ret = get_sealed_data_size(eid, &sealed_data_size);
    if (ret != SGX_SUCCESS)
    {
        // ret_error_support(ret);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 11" << ret << endl;
        return false;
    }
    else if(sealed_data_size == UINT32_MAX)
    {
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 22" << endl;
        return false;
    }

    uint8_t *temp_sealed_buf = (uint8_t *)malloc(sealed_data_size);
    if(temp_sealed_buf == NULL)
    {
        std::cout << "Out of memory" << std::endl;
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 3" << endl;
        return false;
    }
    sgx_status_t retval;
    ret = seal_data(eid, &retval, temp_sealed_buf, sealed_data_size);
    if (ret != SGX_SUCCESS)
    {
        // ret_error_support(ret);
        free(temp_sealed_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 4" << endl;
        return false;
    }
    else if( retval != SGX_SUCCESS)
    {
        // ret_error_support(retval);
        free(temp_sealed_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 5" << endl;
        return false;
    }

    // Save the sealed blob
    if (write_buf_to_file(sealed_db_file, temp_sealed_buf, sealed_data_size, 0) == false)
    {
        std::cout << "Failed to save the sealed data blob to \"" << sealed_db_file << "\"" << std::endl;
        free(temp_sealed_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 6" << endl;
        return false;
    }

    free(temp_sealed_buf);

    std::cout << "Sealing data succeeded." << std::endl;

    // Unsealing
    // Read the sealed blob from the file
    size_t fsize = get_file_size(sealed_db_file);
    if (fsize == (size_t)-1)
    {
        std::cout << "Failed to get the file size of \"" << sealed_db_file << "\"" << std::endl;
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 1" << endl;
        return false;
    }
    uint8_t *temp_buf = (uint8_t *)malloc(fsize);
    if(temp_buf == NULL)
    {
        std::cout << "Out of memory" << std::endl;
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 2" << endl;
        return false;
    }
    if (read_file_to_buf(sealed_db_file, temp_buf, fsize) == false)
    {
        std::cout << "Failed to read the sealed data blob from \"" << sealed_db_file << "\"" << std::endl;
        free(temp_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 3" << endl;
        return false;
    }

    // Unseal the sealed blob
    ret = unseal_data(eid, &retval, temp_buf, fsize);
    if (ret != SGX_SUCCESS)
    {
        // ret_error_support(ret);
        free(temp_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 4" << endl;
        return false;
    }
    else if(retval != SGX_SUCCESS)
    {
        // ret_error_support(retval);
        free(temp_buf);
        sgx_destroy_enclave(eid);
        std::cout << "Error Count: 5" << endl;
        return false;
    }
    for(int i = 0;i < fsize;i++) {
        std::cout << temp_buf[i];
    }

    free(temp_buf);
   
    std::cout << "Unseal succeeded." << std::endl;

    // encrypt database file
    FILE *fp_cmd = NULL;
    size_t file_size;
    char cmd[100] = "wc -c test.db | awk '{print $1}'";
    char _buf[100];

    fp_cmd = popen(cmd, "r");

    if (fp_cmd != NULL) {
        while (fgets(_buf, sizeof(_buf), fp_cmd) != NULL) {
            int fsize = 0;
            for(int i = 0; '0' <= _buf[i] && _buf[i] <= '9'; i++) {
                fsize = fsize * 10 + (_buf[i] - '0');
            }
            file_size = (size_t)fsize;
        }
        pclose(fp_cmd);
    }

    FILE *fp = fopen(dbname, "rb");
    if (fp == NULL) {
        cout << "New file: " << dbname << endl;
    }

    // unsigned char *buf = (unsigned char*)malloc(sizeof(char) * file_size);
    // fread(buf, sizeof(unsigned char), file_size, fp);
    // printf("buf size: %d, file_size: %d", sizeof(buf), file_size);

    // Open SQLite database
    ret = ecall_opendb(eid, dbname);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_open()" << endl;
        return -1;
    }

    cout << "Enter SQL statement to execute or 'quit' to exit: " << endl;
    string input;
    cout << "> ";
    while(getline(cin, input)) {
        if (input == "quit"){
            break;
        }
        const char* sql = input.c_str();
        ret =  ecall_execute_sql(eid, sql);
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_execute_sql()" << endl;
            return -1;
        }
        cout << "> ";
    }

    // Closing SQLite database inside enclave
    ret =  ecall_closedb(eid);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_closedb()" << endl;
        return -1;
    }

    // Destroy the enclave
    sgx_destroy_enclave(eid);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: destroying enclave" << endl;
        return -1;
    }

    cout << "Info: SQLite SGX enclave successfully returned." << endl;
    return 0;
}
